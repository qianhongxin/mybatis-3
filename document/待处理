注意：调试包中调试

数据源中的push和pop方法逻辑，流程图

xpath解析原理

parsing模块，GenericTokenParser的解析逻辑

binding中的mapper生成


spring-mybatis会有自己的sqlsession，transaction等对象.底层还是DefaultSqlSession



druid是怎么实现sql拦截处理的，影响mybatis的statment执行吗？


两条线路：
一条初始化线路
一条运行线路


比如TypeHandlerRegistry，TypeAliasRegistry都是ConcurrentHashMap，HashMap等存储的，map的查找和插入算法的学习

Mybatis 的缓存，二级缓存，与redis等应用操作的缓存。有什么区别？
答： mybatis的缓存都是mybatis自己实现的逻辑，我们操作redis，我们自己可以灵活控制，可以选择缓存更新算法等

分页插件

shardingjdbc，mybatis的插件实现分表的功能

spring的多数据源和拦截器实现分库功能

访问者模式

mybatis-spring是将mybatis的创建工作用spring管理。事务和session交给spring操作



总结：
0. mybatis本身是分层架构

单个软件看起来就是分层架构，因为是方法调用，数据流转。可以看成分层。
然后高内聚低耦合设计。

加入mvc设计就是imvc架构等
高内聚，低耦合。是和语言无关的


参数占位符：
1. ${}是在构建sqlSource时就处理掉了，通过GenericTokenParser parser = new GenericTokenParser("${", "}", handler);处理替换掉,见PropertieyParse
2. #{}是在 SqlSourceBuilder 阶段构建的，所有的SqlSource实现最后在构建阶段都会调用SqlSourceBuilder的parse方法，其中做了如下处理：
    // 如果sql中包含#{}就替换成？，变成预编译的sql。sql编译失败会提醒
    GenericTokenParser parser = new GenericTokenParser("#{", "}", handler);
    将#{}替换成？

3. mybatis默认时，所有的MappedStatement对象的statement类型都是PrepareStatement（参见XMLStatementBuilder类的parseStatementNode方法）

4.      a. Statement:
       普通的不带参的查询SQL；支持批量更新,批量删除;

        b. PreparedStatement:
   　　   可变参数的SQL,编译一次,执行多次,效率高;
   　　   安全性好，有效防止Sql注入等问题;
   　　   支持批量更新,批量删除;
        c. CallableStatement:
   　　继承自PreparedStatement,支持带参数的SQL操作;
   　　支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;

mybatis提供的 DefaultParameterHandler 用于处理 PreparedStatement 和 CallableStatement 的参数。基础的Statement没有参数处理，所以 SimpleStatementHandler 的
parameterize方法是空的实现，即用SimpleStatementHandler执行时，语句没有${}或者#{}这种参数化，就是基本语句

一般我们使用时，不指定statementtype，默认使用的是 PreparedStatement ，指定为 CallableStatement 时，CallableStatement也是PreparedStatement的子类，
所以 PreparedStatement 和 CallableStatement 的参数都是用 ps.setParamater(...) 见 DefaultParameterHandler 的 setParameters 方法指定（如果存在${}或者#{}，即使不存在也可以）

5. RawSqlSource：原始的sqlsource，只支持包含#{}，${}，非动态sql
   DynamicSqlSource：动态sqlsource，支持${},#{},还支持动态sql
   ProviderSqlSource：支持@ProviderXXX等注解形式的sqlsource，包含#{}，${}
   StaticSqlSource：静态的sqlsource构建，为上面的几个服务

   注意：
   只要语句中含有${}，不管有没有#{}，不管有没有if，where等标签: 使用的都是DynamicSqlSource，因为${}占位符是mybatis每次都要重新解析sql，将参数赋值进去
   语句只有#{}或没有参数占位符：使用的是RawSqlSource
   注解形式的mappedStatement，比如@Select等：使用的是 ProviderSqlSource


6. java中boolean默认是false，Boolean默认是null

7. SqlSource是用来创建BoundSql对象，SqlSource有多种形式。见5

8. 每次curd都会产生新的BoundSql对象

9.  拦截器的一个作用就是我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法执行前后加上某些逻辑，
也可以在执行这些被拦截的方法时执行自己的逻辑而不再执行被拦截的方法。Mybatis拦截器设计的一个初衷就是为了供用户在某些时候
可以实现自己的逻辑而不必去动Mybatis固有的逻辑。打个比方，对于Executor，Mybatis中有几种实现：BatchExecutor、ReuseExecutor、
SimpleExecutor和CachingExecutor。这个时候如果你觉得这几种实现对于Executor接口的query方法都不能满足你的要求，那怎么办呢？是要
去改源码吗？当然不。我们可以建立一个Mybatis拦截器用于拦截Executor接口的query方法，在拦截之后实现自己的query方法逻辑，之后可以选
择是否继续执行原来的query方法。

10. mybatis-spring中在一个线程中缓存了sqlsession。但是线程结束，下次再来就又是新的。同一个sqlsession中一级缓存是开启的，用的CacheingExecutor，操作都是从缓存取数据。
这样就不会被插件代理。但是其他线程，新来线程依然是要四大对象（Executor 的方法、 ParameterHandler 的方法、 ResultSetHandler 的 方法 以及 StatementHandler 的方法）被代理，只要匹配

11. mapper代理开发：
我们写的dao接口，代理类的invoke方法中做了固定的 session 调用，不用我们写dao的实现类方法。因为逻辑时固定的。和手动操作session调用一样
但是mapper开发时，dao的类名和方法名组合后必须和xml的namespace+id的组合一样才行。因为mapper的invoke方法中根据这个找statement

12. mybatis的启动是mybatis-spring调用启动的，解析xml等。也可以自己启动，看测试类AutoConstructorTest

13。 默认，Executor是SimpleExecutor，Handler是PrepareHandler

14。 mybatis的缓存操作方案，可以学习。我们操作redis和mysql的时机可以参考

15。 当打开新session时，就要新建executor，那就必须要新建paramterhandler和resultsethandler等。因为executor是新建的，有新的statement需要处理。有新的参数传入，需要重新处理。
其实这是mybatis这样的设计的。他可能考虑的是扩展性，才每次都要新建对象，其实完全可以单例，将字段作为方法参数。这样就能通用。但是他可能考虑多肽。以后可以在xml中配置不同的处理器。
所以这也可能就是设计的复杂，操作耗时就会增多

16。大致执行流程（不含cache）：
创建session{executor} -> statementhandler{paramterhandler,resultsethandler} -> statement -> statementhandler.handler(statement) -> resultsethandler处理结果返回

17. 类加载器
类的字节码加载到内存，只需要一次即可。失去了会重新加载
jdk动态代理涉及到的类Proxy，WeakCache，ProxyClassFactory，ProxyGenerator


18. scripting模块：动态sql处理相关的类
mapping模块：保存映射相关的类，比如参数映射，返回值映射等
executor模块：保存执行器相关的类
binding模块：保存dao接口开发时，dao代理对象和statement的绑定映射关系
builder模块：保存解析xml和注解的类
cache模块：mybatis缓存操作的类
cursor模块：mybatis游标操作的类
datasource模块：数据源的类
exceptions:异常类

19. mybatis-spring：
将工厂类对象注入到spring即可。其他的mybatis核心对象有扩展点加载启动创建，不直接放入spring容器中。想获取他们需要通过工厂对象

20.分库分表的sharding-jdbc。mybatis，hibernate，多数据源等都是基于jdbc来开发的。有jdbc能做很多事

21. 关于 executorType 更改：
1. 可以在mybatis-config.xml中的setting的标签的propertis标签设置，key为 defaultExecutorType，参见XMLConfigBuilder的parseConfiguration方法的
 settingsElement(settings);这一句设置configuration属性的，可以设置defaultExecutorType。默认时defaultExecutorType时SIMPLE。
2. 还可以在创建session时修改。在 SqlSessionFactory.getSqlSession时，可以传想要的类型。但是这种需要手动操作SqlSessionFactory，不方便

22. 各种executorType作用：
SIMPLE：每次都是新建statement对象
REUSE：重复利用statement,当前session没有关闭就可以。如果关闭了，也就消除了
BATCH：这个执行器类型会批量执行所有的更新语句，也是为每个语句的执行创建一个新的预处理语句。我们通常的mybatis只是REUSE类型

不错的文章：
https://blog.csdn.net/u012089657/article/details/49763631

掘金markdown写作语法：https://juejin.im/post/5bd1423751882526f11d4fe2

23. 每次创建sqlsession时，默认创建的executor都是cachingexecutor，一级缓存是开启的

24. Executor有两个query方法，A支持定义key和BoundSql，B不支持。后者用于sqlSession中调用，前者是在executor的实现类中操作的，它支持修改BoundSql，不用非要用MappedStatement中的BoundSql。写自定义插件时，多个插件可能会影响，因为，a插件可能执行的时候底层调用的是A，而我们写的只是拦截B，又因为A被别的拦截器拦截了，所以影响了我们的插件方法执行。具体见博客：

25. mybatis-spring项目中，一个session和一个线程关联。一个线程最多只能关联一个session。这跟jdbc设计有关，jdbc底层是bio模型。如果数据库调用没返回就一直等待返回。期间
线程被阻塞的直到结果返回。多个线程就是多个session。

25。executor中两个query方法区别：
1。 // 查询，带 ResultHandler + CacheKey + BoundSql
2。 // 查询，带 ResultHandler
两个 #query(...) 方法，实际是统一的。带 ResultHandler的query方法暴露给sqlsession调用，带 ResultHandler + CacheKey + BoundSql
的query方法底层使用

26。 多个插件代理同一个方法，比如executor的query方法，注意协调，如果想互不干扰的执行，要注意proceder.proceed()放行才行。

27. java的jdbc已经提供了所有操作接口。上层的分库分表，数据源等都是基于它开发

28. jdbc提供了三种操作sql的入口：
    普通的Statement：非预编译的sql，参数在sql执行前设置进去。容易引起sql注入
    PrepareStatement：预编译的sql，使用时需要设置参数
    CallStatement：存储过程调用

    而且执行sql时，批量sql调用的都是addBatch，非批量都是execute

