数据源中的push和pop方法逻辑，流程图

xpath解析原理

parsing模块，GenericTokenParser的解析逻辑

binding中的mapper生成


spring-mybatis会有自己的sqlsession，transaction等对象


druid是怎么实现sql拦截处理的，影响mybatis的statment执行吗？


两条线路：
一条初始化线路
一条运行线路


比如TypeHandlerRegistry，TypeAliasRegistry都是ConcurrentHashMap，HashMap等存储的，map的查找和插入算法的学习

Mybatis 的缓存，二级缓存，与redis等应用操作的缓存。有什么区别？
答： mybatis的缓存都是mybatis自己实现的逻辑，我们操作redis，我们自己可以灵活控制，可以选择缓存更新算法等

分页插件

shardingjdbc，mybatis的插件实现分表的功能

spring的多数据源和拦截器实现分库功能

访问者模式

mybatis-spring是将mybatis的创建工作用spring管理。事务和session交给spring操作



总结：
参数占位符：
1. ${}是在构建sqlSource时就处理掉了，通过GenericTokenParser parser = new GenericTokenParser("${", "}", handler);处理替换掉,见PropertieyParse
2. #{}是在 SqlSourceBuilder 阶段构建的，所有的SqlSource实现最后在构建阶段都会调用SqlSourceBuilder的parse方法，其中做了如下处理：
    // 如果sql中包含#{}就替换成？，变成预编译的sql
    GenericTokenParser parser = new GenericTokenParser("#{", "}", handler);
    将#{}替换成？

3. mybatis默认时，所有的MappedStatement对象的statement类型都是PrepareStatement（参见XMLStatementBuilder类的parseStatementNode方法）

4.      a. Statement:
       普通的不带参的查询SQL；支持批量更新,批量删除;

        b. PreparedStatement:
   　　   可变参数的SQL,编译一次,执行多次,效率高;
   　　   安全性好，有效防止Sql注入等问题;
   　　   支持批量更新,批量删除;
        c. CallableStatement:
   　　继承自PreparedStatement,支持带参数的SQL操作;
   　　支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;

mybatis提供的 DefaultParameterHandler 用于处理 PreparedStatement 和 CallableStatement 的参数。基础的Statement没有参数处理，所以 SimpleStatementHandler 的
parameterize方法是空的实现，即用SimpleStatementHandler执行时，语句没有${}或者#{}这种参数化，就是基本语句

一般我们使用时，不指定statementtype，默认使用的是 PreparedStatement ，指定为 CallableStatement 时，CallableStatement也是PreparedStatement的子类，
所以 PreparedStatement 和 CallableStatement 的参数都是用 ps.setParamater(...) 见 DefaultParameterHandler 的 setParameters 方法指定（如果存在${}或者#{}，即使不存在也可以）

5. RawSqlSource DynamicSqlSource  ProviderSqlSource的区别？