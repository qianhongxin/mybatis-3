注意：调试包中调试

数据源中的push和pop方法逻辑，流程图

xpath解析原理

parsing模块，GenericTokenParser的解析逻辑

binding中的mapper生成


spring-mybatis会有自己的sqlsession，transaction等对象


druid是怎么实现sql拦截处理的，影响mybatis的statment执行吗？


两条线路：
一条初始化线路
一条运行线路


比如TypeHandlerRegistry，TypeAliasRegistry都是ConcurrentHashMap，HashMap等存储的，map的查找和插入算法的学习

Mybatis 的缓存，二级缓存，与redis等应用操作的缓存。有什么区别？
答： mybatis的缓存都是mybatis自己实现的逻辑，我们操作redis，我们自己可以灵活控制，可以选择缓存更新算法等

分页插件

shardingjdbc，mybatis的插件实现分表的功能

spring的多数据源和拦截器实现分库功能

访问者模式

mybatis-spring是将mybatis的创建工作用spring管理。事务和session交给spring操作



总结：
参数占位符：
1. ${}是在构建sqlSource时就处理掉了，通过GenericTokenParser parser = new GenericTokenParser("${", "}", handler);处理替换掉,见PropertieyParse
2. #{}是在 SqlSourceBuilder 阶段构建的，所有的SqlSource实现最后在构建阶段都会调用SqlSourceBuilder的parse方法，其中做了如下处理：
    // 如果sql中包含#{}就替换成？，变成预编译的sql
    GenericTokenParser parser = new GenericTokenParser("#{", "}", handler);
    将#{}替换成？

3. mybatis默认时，所有的MappedStatement对象的statement类型都是PrepareStatement（参见XMLStatementBuilder类的parseStatementNode方法）

4.      a. Statement:
       普通的不带参的查询SQL；支持批量更新,批量删除;

        b. PreparedStatement:
   　　   可变参数的SQL,编译一次,执行多次,效率高;
   　　   安全性好，有效防止Sql注入等问题;
   　　   支持批量更新,批量删除;
        c. CallableStatement:
   　　继承自PreparedStatement,支持带参数的SQL操作;
   　　支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;

mybatis提供的 DefaultParameterHandler 用于处理 PreparedStatement 和 CallableStatement 的参数。基础的Statement没有参数处理，所以 SimpleStatementHandler 的
parameterize方法是空的实现，即用SimpleStatementHandler执行时，语句没有${}或者#{}这种参数化，就是基本语句

一般我们使用时，不指定statementtype，默认使用的是 PreparedStatement ，指定为 CallableStatement 时，CallableStatement也是PreparedStatement的子类，
所以 PreparedStatement 和 CallableStatement 的参数都是用 ps.setParamater(...) 见 DefaultParameterHandler 的 setParameters 方法指定（如果存在${}或者#{}，即使不存在也可以）

5. RawSqlSource：原始的sqlsource，只支持包含#{}，${}，非动态sql
   DynamicSqlSource：动态sqlsource，支持${},#{},还支持动态sql
   ProviderSqlSource：支持@ProviderXXX等注解形式的sqlsource，包含#{}，${}
   StaticSqlSource：静态的sqlsource构建，为上面的几个服务

   注意：
   只要语句中含有${}，不管有没有#{}，不管有没有if，where等标签: 使用的都是DynamicSqlSource，因为${}占位符是mybatis每次都要重新解析sql，将参数赋值进去
   语句只有#{}或没有参数占位符：使用的是RawSqlSource
   注解形式的mappedStatement，比如@Select等：使用的是 ProviderSqlSource


6. java中boolean默认是false，Boolean默认是null

7. SqlSource是用来创建BoundSql对象，SqlSource有多种形式。见5

8. 每次curd都会产生新的BoundSql对象

9.  拦截器的一个作用就是我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法执行前后加上某些逻辑，
也可以在执行这些被拦截的方法时执行自己的逻辑而不再执行被拦截的方法。Mybatis拦截器设计的一个初衷就是为了供用户在某些时候
可以实现自己的逻辑而不必去动Mybatis固有的逻辑。打个比方，对于Executor，Mybatis中有几种实现：BatchExecutor、ReuseExecutor、
SimpleExecutor和CachingExecutor。这个时候如果你觉得这几种实现对于Executor接口的query方法都不能满足你的要求，那怎么办呢？是要
去改源码吗？当然不。我们可以建立一个Mybatis拦截器用于拦截Executor接口的query方法，在拦截之后实现自己的query方法逻辑，之后可以选
择是否继续执行原来的query方法。

不错的文章：
https://blog.csdn.net/u012089657/article/details/49763631


