http://www.cnblogs.com/LittleHann/p/3695332.html

一个jdbc例子
public void executeSql(String sql)throws Exception
    {
        // 加载驱动
        Class.forName(driver);
        try(
            // 获取数据库连接
            Connection conn = DriverManager.getConnection(url
                , user , pass);
            // 使用Connection来创建一个Statement对象
            Statement stmt = conn.createStatement())
        {
            // 执行SQL,返回boolean值表示是否包含ResultSet
            boolean hasResultSet = stmt.execute(sql);
            // 如果执行后有ResultSet结果集
            if (hasResultSet)
            {
                try(
                    // 获取结果集
                    ResultSet rs = stmt.getResultSet())
                {
                    // ResultSetMetaData是用于分析结果集的元数据接口
                    ResultSetMetaData rsmd = rs.getMetaData();
                    int columnCount = rsmd.getColumnCount();
                    // 迭代输出ResultSet对象
                    while (rs.next())
                    {
                        // 依次输出每列的值
                        for (int i = 0 ; i < columnCount ; i++ )
                        {
                            System.out.print(rs.getString(i + 1) + "\t");
                        }
                        System.out.print("\n");
                    }
                }
            }
            else
            {
                System.out.println("该SQL语句影响的记录有"
                    + stmt.getUpdateCount() + "条");
            }
        }
    }

https://blog.csdn.net/yerenyuan_pku/article/details/52387676

jdbc编程的事务管理，就是用connection的commit方法来做的。mybatis，hibernate等orm框架用session
封装的executor对象，executor封装了transaction对象，transaction封装了connection对象来做的


关于预编译 sql 理解：
这种方式能防范SQL注入的原理是在SQL参数未注入之前，提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。
也就是说其后注入进来的参数系统将不会认为它会是一条SQL语句，而默认其是一条一个参数。
https://www.cnblogs.com/zouqin/p/5314827.html

jdbc

sharding-jdbc
